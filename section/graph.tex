\section{graph / グラフ}
\subsection{ベルマンフォード}
ベルマンフォード法
$O(V^2)$
sから到達可能な負の閉路が存在する場合はV回目のループが発生する.
\lstinputlisting[caption=ベルマンフォード]{src/graph/bellman_ford.cpp}

\subsection{ダイクストラ法}
ダイクストラ法
$O(E \log V)$
sから各頂点に対して最短路を求める.
\lstinputlisting[caption=ダイクストラ法]{src/graph/dijkstra.cpp}

 \subsection{ワーシャルフロイド法}
全頂点間の最短路を求める.
\lstinputlisting[caption=ワーシャルフロイド法]{src/graph/warshall_floyd.cpp}

\subsection{最小全域木}
\subsubsection{プリム法}
以下の実装は$O(V^2)$.プライオリティキューを用いると$O(E \log V)$に落とせる．
貪欲的にすでに構成された最小全域木頂点集合とそれ以外の頂点を結ぶ辺のコストが最小になる頂点を追加する．
\lstinputlisting[caption=プリム法]{src/graph/prim.cpp}

\subsubsection{クラスカル法}
$O(E \log V)$
コストが低い順に辺を追加していく．UnionFindで閉路判定
\lstinputlisting[caption=プリム法]{src/graph/kruskal.cpp}

\subsection{フォードファルカーソン法}
フォードファルカーソン法
$O(F|E|)$
最大流
\lstinputlisting[caption=フォードファルカーソン法]{src/graph/ford_fulkerson.cpp}

\subsection{最小費用流}
$O(F|E|log|V|)$
最小費用流
\lstinputlisting[caption=最小費用流]{src/graph/min_cost_flow_dijkstra.cpp}

\subsection{二部マッチング}
$O(F|E|)$
\lstinputlisting[caption=二部マッチング]{src/graph/bipartile_matching.cpp}

\subsection{強連結成分分解}
$O(|V|+|E|)$
\lstinputlisting[caption=強連結成分分解]{src/graph/strongly_connected_component.cpp}
